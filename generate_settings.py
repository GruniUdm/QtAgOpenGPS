#!/usr/bin/python3

import sys
import csv

def generate_addkeys(reader):
    print ("""#include "settings.h"

void Settings::setupKeys() {
""")
    for row in reader:
        if row['cpp_type'] == 'double': row['cpp_type'] = 'Double'
        if row['cpp_type'] == 'int': row['cpp_type'] = 'Int'
        if row['cpp_type'] == 'bool': row['cpp_type'] = 'Bool'
        if not row['cpp_type']: row['cpp_type'] = 'Void'

        if row["cpp_type"][:8] == 'METATYPE':
            print('    addKey("%s/%s", toVariant(%s), QMetaType(%s));' % (row['section'],row['key'], row['default'], row['cpp_type']))
        else:
            print('    addKey("%s/%s", %s, QMetaType(QMetaType::%s));' % (row['section'],row['key'], row['default'], row['cpp_type']))


    print ("}")
    print ()

def generate_header(reader):
    print ("#ifndef __SETTINGS_KEYS_H__")
    print ("#define __SETTINGS_KEYS_H__")

    print ()
    print ('#include "settings.h"')
    print ()
    print ('//Generated by generate_settings.py from settings.csv')
    print ()

    for row in reader:
        print('#define SETTINGS_%s_%s "%s/%s"' % (row['section'], row['key'], row['section'], row['key']))

    print ("#endif")

def color_to_hex(rgblist):
    color_str = '"#'
    for c in rgblist:
        color_str += "%02x" % int(c)

    return color_str + '"'

def generate_mockqml(reader):
    print ()
    print ("//This is a mock Settings singleton for use in qml viewer or QtDS")
    print ("//This mirrors the structure of the real Settings.Settings used")
    print ("//in the compiled binary.")
    print ()
    print ("pragma singleton")
    print ()
    print ("Item {")

    for row in reader:
        if row['cpp_type'][:8] == 'METATYPE':
            qml_type = 'var'

            # instead of a greedy regex, we use a hack slicing job
            # to make sure that if any of the values have { or } in
            # them, we keep them.  Only looking for the first { and the
            # last } to slice.
            default = ''.join(row['default'].split('{')[1:]).split('}')
            row['default'] = '[ ' + '}'.join(default[:-1]) + ' ]'
        else:
            qml_type = row['cpp_type']
            if qml_type == 'QString': 
                qml_type = 'string'
                if row['default'][:7].lower() == 'qstring':
                    row['default'] =  row['default'][8:-1]
            elif qml_type == 'QPoint': 
                qml_type = 'point'
                if row['default'][:2].lower() == 'qp':
                    row['default'] = 'Qt.p' +  row['default'][2:]
            elif qml_type == 'QRect': 
                qml_type = 'rect'
                if row['default'][:2].lower() == 'qr':
                    row['default'] = 'Qt.r' +  row['default'][2:]
            elif qml_type == 'QSize':
                qml_type = 'size'
                if row['default'][:2].lower() == 'qs':
                    row['default'] = 'Qt.s' +  row['default'][2:]
            elif qml_type == 'QColor':
                qml_type = 'color'
                if row['default'][:17].lower() == 'qcolor::fromrgbf(':
                    color = row['default'][17:-1]
                    if ',' in color:
                        color = [float(c.strip()) * 255 for c in color.split(',')]
                        color = color_to_hex(color)
                    row['default'] = color
                if row['default'][:16].lower() == 'qcolor::fromrgb(':
                    color = row['default'][16:-1]
                    if ',' in color:
                        color = [int(c.strip()) for c in color.split(',')]
                        color = color_to_hex(color)
                    row['default'] = color
                if row['default'][:7].lower() == 'qcolor(':
                    color = row['default'][7:-1]
                    if ',' in color:
                        color = [int(c.strip()) for c in color.split(',')]
                        color = color_to_hex(color)
                    row['default'] = color

        print("	property %s %s_%s: %s" % (qml_type, row['section'], row['key'], row['default']))


    print ("}")

def generate_sed(reader):
    for row in reader:
        print ('s|\\"%s/%s\\"|SETTINGS_%s_%s|g' % (row['section'], row['key'], row['section'], row['key']))


if __name__ == "__main__":
    import argparse

    argparser = argparse.ArgumentParser(prog = sys.argv[0],
                                        description = 'Parse settings.csv and generate newsettings_addkeys.cpp and Settings.qml for the mock AOG module for qml viewer')
    argparser.add_argument('-a', '--addkeys', action = 'store_true', help = 'Generate the newsettings_addkeys.cpp file')
    argparser.add_argument('-m', '--mockqml', action = 'store_true', help = 'Generate the mock Settings.qml file')
    argparser.add_argument('-c', '--header', action = 'store_true', help = 'Generate convenience macro header file')
    argparser.add_argument('-s', '--sed', action = 'store_true', help = 'Generate a list of sed expressions to convert code from using strings to using macros from settings_defines.h for better compile-time error checking.')
    argparser.add_argument('csv_file', help = 'path to settings.csv file.')

    args = argparser.parse_args()

    with open(args.csv_file,'r') as csv_file:
        reader = csv.DictReader(csv_file, quotechar="'")

        if (args.sed):
            generate_sed(reader)
        else:
            
            print ("// Copyright (C) 2024 Michael Torrie and the QtAgOpenGPS Dev Team")
            print ("// SPDX-License-Identifier: GNU General Public License v3.0 or later")
            print ("//")

            if (args.addkeys):
                generate_addkeys(reader)
            elif (args.header):
                generate_header(reader)
            elif (args.mockqml):
                generate_mockqml(reader)
            else:
                print ("Unknown option.")

