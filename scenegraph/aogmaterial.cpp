// Copyright (C) 2024 Michael Torrie and the QtAgOpenGPS Dev Team
// SPDX-License-Identifier: GNU General Public License v3.0 or later
//
// Custom QSGMaterial implementations for scene graph rendering

#include "aogmaterial.h"
#include <QFile>
#include <QDebug>
#include <QLoggingCategory>

Q_LOGGING_CATEGORY(aogmaterial_log, "aogmaterial.qtagopengps")

// ============================================================================
// AOGFlatColorMaterial Implementation
// ============================================================================

static QSGMaterialType flatColorMaterialType;

AOGFlatColorMaterial::AOGFlatColorMaterial()
{
    // Enable blending for transparency support
    setFlag(Blending);
}

QSGMaterialType *AOGFlatColorMaterial::type() const
{
    return &flatColorMaterialType;
}

QSGMaterialShader *AOGFlatColorMaterial::createShader(QSGRendererInterface::RenderMode) const
{
    return new AOGFlatColorShader();
}

int AOGFlatColorMaterial::compare(const QSGMaterial *other) const
{
    const auto *o = static_cast<const AOGFlatColorMaterial *>(other);

    // Compare color
    if (m_color.rgba() != o->m_color.rgba())
        return m_color.rgba() < o->m_color.rgba() ? -1 : 1;

    // Compare MVP matrix (simple pointer comparison for now - matrices differ per instance)
    // This means each geometry node will have its own batch, which is expected for 3D
    if (m_mvpMatrix != o->m_mvpMatrix)
        return &m_mvpMatrix < &o->m_mvpMatrix ? -1 : 1;

    return 0;
}

void AOGFlatColorMaterial::setColor(const QColor &color)
{
    m_color = color;
}

void AOGFlatColorMaterial::setMvpMatrix(const QMatrix4x4 &mvp)
{
    m_mvpMatrix = mvp;
}

void AOGFlatColorMaterial::setPointSize(float size)
{
    m_pointSize = size;
}

// ============================================================================
// AOGFlatColorShader Implementation
// ============================================================================

AOGFlatColorShader::AOGFlatColorShader()
{
    // Load pre-compiled shaders from .qsb files
    // These are generated by qt_add_shaders in CMakeLists.txt
    setShaderFileName(VertexStage, QLatin1String(":/AOG/shaders/color_vshader.vert.qsb"));
    setShaderFileName(FragmentStage, QLatin1String(":/AOG/shaders/color_fshader.frag.qsb"));
}

bool AOGFlatColorShader::updateUniformData(RenderState &state, QSGMaterial *newMaterial, QSGMaterial *oldMaterial)
{
    Q_UNUSED(oldMaterial);

    bool changed = false;
    QByteArray *buf = state.uniformData();

    auto *material = static_cast<AOGFlatColorMaterial *>(newMaterial);

    // Uniform buffer layout (std140):
    // offset 0:  mat4 mvpMatrix (64 bytes)
    // offset 64: vec4 color (16 bytes)
    // offset 80: float pointSize (4 bytes, padded to 16)

    // Update MVP matrix
    // Our MVP transforms: world coords -> item-local coords
    // state.combinedMatrix() transforms: item-local coords -> window clip space
    // Combined: world coords -> window clip space, properly positioned in the item
    QMatrix4x4 combinedMatrix = state.combinedMatrix() * material->mvpMatrix();
    memcpy(buf->data(), combinedMatrix.constData(), 64);
    changed = true;

    // Update color
    QColor c = material->color();
    float colorData[4] = {
        static_cast<float>(c.redF()),
        static_cast<float>(c.greenF()),
        static_cast<float>(c.blueF()),
        static_cast<float>(c.alphaF())
    };
    memcpy(buf->data() + 64, colorData, 16);
    changed = true;

    // Update point size
    float pointSize = material->pointSize();
    memcpy(buf->data() + 80, &pointSize, 4);

    return changed;
}

// ============================================================================
// AOGVertexColorMaterial Implementation
// ============================================================================

static QSGMaterialType vertexColorMaterialType;

AOGVertexColorMaterial::AOGVertexColorMaterial()
{
    setFlag(Blending);
}

QSGMaterialType *AOGVertexColorMaterial::type() const
{
    return &vertexColorMaterialType;
}

QSGMaterialShader *AOGVertexColorMaterial::createShader(QSGRendererInterface::RenderMode) const
{
    return new AOGVertexColorShader();
}

int AOGVertexColorMaterial::compare(const QSGMaterial *other) const
{
    const auto *o = static_cast<const AOGVertexColorMaterial *>(other);

    if (m_mvpMatrix != o->m_mvpMatrix)
        return &m_mvpMatrix < &o->m_mvpMatrix ? -1 : 1;

    return 0;
}

void AOGVertexColorMaterial::setMvpMatrix(const QMatrix4x4 &mvp)
{
    m_mvpMatrix = mvp;
}

void AOGVertexColorMaterial::setPointSize(float size)
{
    m_pointSize = size;
}

// ============================================================================
// AOGVertexColorShader Implementation
// ============================================================================

AOGVertexColorShader::AOGVertexColorShader()
{
    setShaderFileName(VertexStage, QLatin1String(":/AOG/shaders/colors_vshader.vert.qsb"));
    setShaderFileName(FragmentStage, QLatin1String(":/AOG/shaders/colors_fshader.frag.qsb"));
}

bool AOGVertexColorShader::updateUniformData(RenderState &state, QSGMaterial *newMaterial, QSGMaterial *oldMaterial)
{
    Q_UNUSED(oldMaterial);

    bool changed = false;
    QByteArray *buf = state.uniformData();

    auto *material = static_cast<AOGVertexColorMaterial *>(newMaterial);

    // Uniform buffer layout (std140):
    // offset 0:  mat4 mvpMatrix (64 bytes)
    // offset 64: float pointSize (4 bytes, padded to 16)

    // Update MVP matrix - combine with scene graph's matrix for proper positioning
    QMatrix4x4 combinedMatrix = state.combinedMatrix() * material->mvpMatrix();
    memcpy(buf->data(), combinedMatrix.constData(), 64);
    changed = true;

    // Update point size
    float pointSize = material->pointSize();
    memcpy(buf->data() + 64, &pointSize, 4);
    changed = true;

    return changed;
}

// ============================================================================
// AOGTextureMaterial Implementation
// ============================================================================

static QSGMaterialType textureMaterialType;

AOGTextureMaterial::AOGTextureMaterial()
{
    setFlag(Blending);
}

QSGMaterialType *AOGTextureMaterial::type() const
{
    return &textureMaterialType;
}

QSGMaterialShader *AOGTextureMaterial::createShader(QSGRendererInterface::RenderMode) const
{
    return new AOGTextureShader();
}

int AOGTextureMaterial::compare(const QSGMaterial *other) const
{
    const auto *o = static_cast<const AOGTextureMaterial *>(other);

    // Compare texture first (most important for batching)
    if (m_texture != o->m_texture)
        return m_texture < o->m_texture ? -1 : 1;

    if (m_mvpMatrix != o->m_mvpMatrix)
        return &m_mvpMatrix < &o->m_mvpMatrix ? -1 : 1;

    if (m_color.rgba() != o->m_color.rgba())
        return m_color.rgba() < o->m_color.rgba() ? -1 : 1;

    if (m_useColor != o->m_useColor)
        return m_useColor ? 1 : -1;

    return 0;
}

void AOGTextureMaterial::setMvpMatrix(const QMatrix4x4 &mvp)
{
    m_mvpMatrix = mvp;
}

void AOGTextureMaterial::setTexture(QSGTexture *texture)
{
    m_texture = texture;
}

void AOGTextureMaterial::setColor(const QColor &color)
{
    m_color = color;
}

void AOGTextureMaterial::setUseColor(bool use)
{
    m_useColor = use;
}

// ============================================================================
// AOGTextureShader Implementation
// ============================================================================

AOGTextureShader::AOGTextureShader()
{
    setShaderFileName(VertexStage, QLatin1String(":/AOG/shaders/colortex_vshader.vert.qsb"));
    setShaderFileName(FragmentStage, QLatin1String(":/AOG/shaders/colortex_fshader.frag.qsb"));
    //qCDebug(aogmaterial_log) << "AOGTextureShader: Created, loading shaders from :/AOG/shaders/colortex_*.qsb";
}

bool AOGTextureShader::updateUniformData(RenderState &state, QSGMaterial *newMaterial, QSGMaterial *oldMaterial)
{
    Q_UNUSED(oldMaterial);

    bool changed = false;
    QByteArray *buf = state.uniformData();

    auto *material = static_cast<AOGTextureMaterial *>(newMaterial);
    //qCDebug(aogmaterial_log) << "AOGTextureShader::updateUniformData called, texture:" << material->texture();

    // Uniform buffer layout (std140):
    // offset 0:  mat4 mvpMatrix (64 bytes)
    // offset 64: vec4 color (16 bytes)
    // offset 80: int useColor (4 bytes, padded to 16)

    // Update MVP matrix - combine with scene graph's matrix for proper positioning
    QMatrix4x4 combinedMatrix = state.combinedMatrix() * material->mvpMatrix();
    memcpy(buf->data(), combinedMatrix.constData(), 64);
    changed = true;

    // Update color
    QColor c = material->color();
    float colorData[4] = {
        static_cast<float>(c.redF()),
        static_cast<float>(c.greenF()),
        static_cast<float>(c.blueF()),
        static_cast<float>(c.alphaF())
    };
    memcpy(buf->data() + 64, colorData, 16);

    // Update useColor flag
    int useColor = material->useColor() ? 1 : 0;
    memcpy(buf->data() + 80, &useColor, 4);

    changed = true;

    return changed;
}

void AOGTextureShader::updateSampledImage(RenderState &state, int binding, QSGTexture **texture,
                                          QSGMaterial *newMaterial, QSGMaterial *oldMaterial)
{
    Q_UNUSED(oldMaterial);

    //qCDebug(aogmaterial_log) << "AOGTextureShader::updateSampledImage called, binding:" << binding;

    if (binding != 1)
        return;

    auto *material = static_cast<AOGTextureMaterial *>(newMaterial);
    QSGTexture *t = material->texture();
    if (t) {
        // This is critical - commits the texture data to the GPU
        t->commitTextureOperations(state.rhi(), state.resourceUpdateBatch());
        //qCDebug(aogmaterial_log) << "AOGTextureShader: Committed texture at binding 1:" << t;
    }
    *texture = t;
}
